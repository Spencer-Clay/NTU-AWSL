# 陆玺州学习报告03

本周我主要学习了CTFd的搭建，云服务器的使用、SSH远程登录工具FinalShell、docker的简单使用

## EZ_RSA复现

[来源:NEWSctf](https://blog.csdn.net/qq_55400494/article/details/117464317)

```python
import gmpy2
import sympy
from Crypto.Util.number import *
from flag import flag

z=getPrime(1024)
p=sympy.nextprime(z)
q=sympy.prevprime(10*z)
n=p*q

m=bytes_to_long(flag)
e=0xe18e
c=pow(m,e,n)
print(c)

#n=0x2c404d87c6244ad1b44aabd95244d5deb3c93cf3bd798ba4624cd9f89c95e246aad9cbda463292c6ef3140d97c5c1e691c54095e75f56d61a1640decc83caccce52c957282949bed20105d4d67c2b4c3d4c15829657e246d899917022e6d4d07c4382bcc3b83376d7250d85088dc73b24d030f4625fb37c5405cee04ace903d68747035fd55946ad2eb807db0b0508fc24fd54185614ab18c83127b7aa48f9927cc1258f819e02c5d2db4074736e374616664a2b49d1ff3a3effc4af201f235af5193a6e9a0192bb39aad91c5291a1b53973a85bec5dbbb3350e6c344b445c71212938d56a0c99e571bd15356979c394f84398143033fc44eb40558f253bb2445
#c=0x73658446624aaccfefa351499ece4c4635f61ff9d9d9354236afbad3b9e4000582b192f92a6e7e96b60a8899610a841faee92cb38d0e195587977cb806ecb7e4ffe8772f34cec9e0957f28040466306fe5db43b96824aa45bbebed9c1dbf15ac13db238234b60b36bded6e137483b307296e76902a13914065004a289b2186777f1c93ca656a19e751d0e7cf8c090803242ccfe14746c43fe6785028cef6380c590d59ed3469f27ac1769fa2f7fe22eace6e9af1ee33f57b120dacddabbd09239bfc133e79945af9a01568aa1e44e79813fa2e9069fb755823c4bee745f6404c1a5b690f5ba5d52c9b783bd0dfc3a4d473e99879241c0453de76be0e72980d39

```



已知 n 有两个质因数p 和 q 

q 和 10*p比较接近

p 和 q难以 用[在线质因数分解工具](http://factordb.com/)或者yafu分解出



#### q 和 t * p 很接近

设 `q = t * p + k`,    k 一般在 (-10000,10000) 范围内

`n = p * q = t * p ** 2 + k * p`

`S = 4 * t * n + k ** 2 = (2tp) ** 2 + 2 * (2tp) + k ** 2`

构造了完全平方式 `S = (2tp + k) ** 2`

找到能整开方的 `S` 来求出 `k` 和 `(2tp + k)`, 进而得到`p`、`q`

求得`phi = (p-1) * (q-1)`



#### e和phi不互素

`e模phi的乘法逆元d`存在的充要条件是 `gcd(e,phi) = 1`

gmpy2.gcd(e,phi)能得到e和phi的最大公因数`h`

`e' = e // h ,  m' = m ** h`

`pow(m,e,n) = pow(m**h,e // h, n) = pow(m'.e',n)`

e' 跟 phi 互素 

gmpy2.invert(e’,phi)求得 e' 模phi的逆 d‘

`m ** h = m' = pow(c,d',n)`



```python
n=89379109394029280970559142773910507137312841371095763817666537804103549694994475893533103181199539544132627370915381381684826444643070606444864549418529590840953923177237642744014373937763397577259957981152660688518289282345718965481604661566565380826259153258991542131366556400290425175645850630123731466171661729854393959121615970548753257630821742942145215238276087210290974263658526136179453067036424705394295501477981995757972469088950044042157851142522966279309365553960767911674503860157139796807947534002561903393659969740924063606081595957056084244888961588709661995921049112030525676941422779586388642440261
t=10
 
import gmpy2
for k in range(-10000,10000):
    x=gmpy2.iroot(k**2+4*t*n,2)   #  (2tp + k) ** 2
    
    if x[1]:
        
            p=(-k+x[0])//(2*t)
            q=t*p+k
            break
        
import gmpy2
from Crypto.Util.number import long_to_bytes,bytes_to_long
phi=(p-1)*(q-1)
e=57742
c=14567464821113193726690379208635877774064774155869176861519786913451062659990087716712397661348565349805194086610154588543875244259506057415292321666586974792275800118075148091774040539089299096402473260341114362099657263027884229377457131318429769846978447430150504970383412453005997207861560228519562367870935277347099232185198500356408101594936161425554142292628816443215790772416550953938773956798433731654455952497284594672139583080143102015841344105225518870476647065718341950402344619984207919154882834205268981968163229843692054521177400031002262139843560115162798400110263794053785704500186241960584410565945
 
h=gmpy2.gcd(e,phi)
d=gmpy2.invert(e//h,phi)
m=pow(c,d,n)    #m' = pow(c,d',n)
msg=gmpy2.iroot(m,h) #对m开h次方，如果结果为整数，msg[0]为结果, msg[1]为True
if msg[1]:  
    print(long_to_bytes(msg[0]))
 
#flag{y0u_@re_VerY_g0od}
```



### CRYPTO_1

```python
import random
import sympy
from Crypto.Util.number import *
import gmpy2
from secret import flag

assert(type(flag) is bytes)

x = random.randint(512,1024)
p = getPrime(x)
q = sympy.prevprime(x*p)
n = p * q 
m = bytes_to_long(flag)

e = 0x20002

c = pow(m,e,n)

print(n)
print(c)

#15214472517167635208179643871723259963705575223003295590996880190560499744418265895580813509605164471913428513155764630161636980830802633813663336583213161569538178508437359943631196481047739347775324187472085993738794470299908710911049348940248532805473566951285681866468589043457843762688499849012440295414493451692467370543822040652333188332816025075165979672831581290945925240985893490532001382605626325382054628858274579650347717335461976163004389030535919832078653634505987851574185666635841464028165894065757887647087214520446546500620861128042817428764084656276550191632918086102769087568522630555195097
#11058520079170522803684585219901898801255613478645626974872504406690922945753785010861582796210750226475971920185096520692686992176009934573619610958733046237941697968314511032451851585467734569392407182980753533348751810814013718365754750869633257153873276933960267067855974698884842720285929150910465894787273762026450256965090665900254208885227595964548981953518254550953773629567607146974719685702329042657032685765607803435883527947475703743642842955033421775334843375224801155478219009956642226332623779306451050115135524258410411580785604692272741152498796424309784159909128642849761091942473987146661728

```

`q` 和 `t * p` 很接近

已知`p`的长度范围和`t`的范围

构造`S = 4 * t * n + k ** 2 = (2tp + k) ** 2`

根据`S能整开方`，

在`t`的范围`(512,1024)`, `k`的范围`(-10000,10000)` 中爆破出`t`、`k`

```python
from sympy import nextprime, prevprime
from Crypto.Util.number import *
import gmpy2
#from secret import flag

n = 15214472517167635208179643871723259963705575223003295590996880190560499744418265895580813509605164471913428513155764630161636980830802633813663336583213161569538178508437359943631196481047739347775324187472085993738794470299908710911049348940248532805473566951285681866468589043457843762688499849012440295414493451692467370543822040652333188332816025075165979672831581290945925240985893490532001382605626325382054628858274579650347717335461976163004389030535919832078653634505987851574185666635841464028165894065757887647087214520446546500620861128042817428764084656276550191632918086102769087568522630555195097
c = 11058520079170522803684585219901898801255613478645626974872504406690922945753785010861582796210750226475971920185096520692686992176009934573619610958733046237941697968314511032451851585467734569392407182980753533348751810814013718365754750869633257153873276933960267067855974698884842720285929150910465894787273762026450256965090665900254208885227595964548981953518254550953773629567607146974719685702329042657032685765607803435883527947475703743642842955033421775334843375224801155478219009956642226332623779306451050115135524258410411580785604692272741152498796424309784159909128642849761091942473987146661728

for t in range(512,1024):
    for k in range(-10000, 10000):
        S = gmpy2.iroot(k ** 2 + 4 * t * n, 2)
        if S[1]:   
            p = (-k + S[0]) // (2 * t)
            q = t * p + k
            print("p={}\nq={}\nx={}".format(p,q,t))
            break

e=0x20002

phi = (p - 1) * (q - 1)
e = 0x20002 # e = e1 * h    e1与phi互质
h = gmpy2.gcd(e, phi)   # e' * h == e
e1 = e//h  
d = gmpy2.invert(e1, phi)  #  c = pow(m ** h,e1,n)， d 是 e1 模 phi 的逆
m = pow(c, d, n)  #m'
msg = gmpy2.iroot(m, h)  #对m开h次方，如果结果为整数，msg[0]为结果, msg[1]为True
if msg[1]:
    print(long_to_bytes(msg[0]))

```





## MISC - Plain Text

```text
ZE9CUk8gUE9WQUxPV0FUWCBOQSBNQVReLCBXWSBET0xWTlkgUEVSRVdFU1RJIFxUTyBOQSBBTkdMSUpTS0lKIFFaWUsuIHRXT0ogU0VLUkVUIFNPU1RPSVQgSVogRFdVSCBTTE9XLiB3U0UgQlVLV1kgU1RST15OWUUuIHFCTE9eTllKIEFSQlVaLiB2RUxBRU0gV0FNIE9UTEleTk9HTyBETlEu 
```

base64

```text
dOBRO POVALOWATX NA MAT^, WY DOLVNY PEREWESTI \TO NA ANGLIJSKIJ QZYK. tWOJ SEKRET SOSTOIT IZ DWUH SLOW. wSE BUKWY STRO^NYE. qBLO^NYJ ARBUZ. vELAEM WAM OTLI^NOGO DNQ.
```

搜索发现`dOBRO POVALOWATX`与俄⽂相关，结合上⽂基本都是英⽂字⺟，则根据以下信息：

Ааa发⾳类似英语father⾥的a。Ббb发⾳类似英语 bank⾥的b。Ввv发⾳类似英语victor⾥的v。

Ггg发⾳类似英语good⾥的g。Ддd发⾳类似英语dog⾥的g。Eеe或ye发⾳类似英语yes⾥的y。

Ёёyo发⾳类似英语yogurt⾥的yo。Жжzh发⾳类似法语jour⾥的j。Ззz发⾳类似英语zebra⾥的z。

Ииi发⾳类似英语see⾥的ee。Ййj发⾳类似英语boy⾥的y。Ккk发⾳类似英语kite⾥的k。 

Лл发⾳类似英语like⾥的l。Ммm发⾳类似英语mile⾥的m。Ннn发⾳类似英语no⾥的n。 

Ооo发⾳类似英语port⾥的or，不重读时弱化。Ппp发⾳类似英语put⾥的p。Pрr卷⾆颤⾳。 

Ссs发⾳类似英语sit⾥的s。Tтt发⾳类似英语tea⾥的t。ууu发⾳类似英语fool⾥的oo。фf发⾳类似英语face⾥的f。 

得到转换后的俄⽂：

```perl
дОБРО ПОВАЛОШАТХ НА МАТ^,ШЫ ДОЛВНЫ ПЕРЕШЕСТИ эТО НА АНГЛИЙСКИЙ ЯЗЫК. тШОЙ СЕКРЕТ СОСТОИТ ИЗ ДBa СЛОBa. шСЕ БУКШЫ СТРО^НЫЕ. яБЛО^НЫЙ АРБУЗ. вЕЛАЕМ ШАМ ОТЛИ^НОГО ДНЯ.
```

翻译：

```text
WELCOME TO MATH, YOU SHOULD TRANSFER THIS TO ENGLISH. YOUR SECRET IS A TWO WORD. ALL LETTERS ARE SMALL.APPLE ^ WATERMELON. WE HAVE A GOOD DAY.
```





## 笔记

### sympy科学计算库

SymPy是一个符号计算的Python库。它的目标是成为一个全功能的计算机代数系统，同时保持代码简 洁、易于理解和扩展。它完全由Python写成，不依赖于外部库。SymPy支持符号计算、高精度计算、模式匹配、绘图、解方程、微积分、组合数学、离散 数学、几何学、概率与统计、物理学等方面的功能。([来自维基百科的描述](https://zh.wikipedia.org/wiki/SymPy))

[资料链接](https://www.bbsmax.com/A/1O5EwQE4z7/)

### gmpy2相关方法

```python
import gmpy2
gmpy2.mpz(n) #初始化⼀个⼤整数
gmpy2.mpfr(x) # 初始化⼀个⾼精度浮点数x
d = gmpy2.invert(e,n) # 求逆元，de = 1 mod n
C = gmpy2.powmod(M,e,n) # 幂取模 (M^e) mod n
gmpy2.is_prime(n) #素性检测
gmpy2.gcd(a,b) #欧⼏⾥得算法，最⼤公约数
gmpy2.gcdext(a,b) #扩展欧⼏⾥得算法
gmpy2.iroot(x,n) #x开n次根
--------------------------------------------------------
```

[其他常用函数](https://blog.csdn.net/weixin_43790779/article/details/108473984)

[gmpy2库安装](http://www.bubuko.com/infodetail-3649505.html)